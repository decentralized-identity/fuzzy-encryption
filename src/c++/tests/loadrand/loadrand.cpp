/**
 * This demonstrates how the caller can specify the random bytes used
 * in the cryptographic calculations which could be useful for debugging
 * purposes.
 **/

#include <iostream>
#include <exception>
#include <fstream>
#include <sstream>
#include <string>
#include "fuzzy.h"
#include "input.h"

using namespace std;
using namespace fuzzy_vault;

/// Workhorse routine
///
int work()
{
    /*
    This string contains the "randomBytes" field which is typically absent.
    This forces the code to use the specified string to define the random
    bytes defined there. Each byte is represented as two upper case hexadecimal
    characters; as such, each line must have an even number of characters.
    Internally, the lines are appended into a byte array cache. The minimum
    number of bytes required, if you choose to specify, is 32 + 4 * setSize.
    In this case I round up to the nearest value of 32 to make the strings
    look nice. If you choose to define your own random bytes in this manner
    then the should be generated by a cryptographically secure random
    number generator. Caveat Emptor.

    */
    string input_string = 
        "{\n"
        "  \"setSize\": 9,\n"
        "  \"corpusSize\": 7776,\n"
        "  \"correctThreshold\": 6,\n"
        "  \"randomBytes\": [\n"
        "    \"3218C8B6681167BC81BBCA7523FEFCBD9533F8B31EEA493296B1E089FA0E2E04\",\n"
        "    \"E9DA670216EBDA73F1626012E64576C06D00D0F3A96BC9256972B4C314729D29\",\n"
        "    \"C765880C27EC4EED06155B85C43D35264E7DEF17FC01B8C3EDB5F0B3E2E1EFBE\"\n"
        "  ]\n"
        "}";
    string original_words = "[  1, 2, 3, 4, 5, 6, 7, 8, 9 ]";
    int key_count = 1;

    string params = gen_params(input_string);
    string secret = gen_secret(params, original_words);

    cout << endl << "input_string" << endl << input_string << endl;
    cout << endl << "params" << endl << params << endl;
    cout << endl << "secret" << endl << secret << endl;

    try
    {
        cout << endl << "original_words: " << original_words << endl;
        string original_keys = gen_keys(secret, original_words, key_count);
        cout << endl << "original keys: " << endl << original_keys << endl;

        string recovery_words = "[  1, 2, 3, 4, 5, 66, 77, 8, 99 ]";
        cout << endl << "recovery_words: " << recovery_words << endl;
        // 3 errors -- should be OK
        string recovered_keys = gen_keys(secret, recovery_words, key_count);
        cout << endl << "recovered keys: " << endl << recovered_keys << endl;
        if (recovered_keys != original_keys)
            return 1;

        string bad_words      = "[  1, 2, 3, 4, 5, 66, 77, 88, 99 ]";
        // 4 errors -- too much
        cout << endl << "bad_words: " << bad_words << endl;
        cout << "attempting to recover the keys ..." << endl;
        string bad_keys = gen_keys(secret, bad_words, key_count);
        return 2;  // should not get here
    }
    catch(const NoSolutionException)
    {
        cout << "keys could not be recovered -- as expected" << endl;
    }
    cout << endl << "All tests passed!" << endl;
    return 0;
}

int main(int argc, char* argv[])
{
    try
    {
        return work();
    }
    catch(const exception& e)
    {
        cerr << e.what() << '\n';
        return 1;
    }
}
