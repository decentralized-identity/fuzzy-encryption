#ifndef _SECRET_H_
#define _SECRET_H_

#include <ostream>
#include <stdint.h>
#include <vector>
#include "poly.h"
#include "params.h"

/// The secret state used to recover keys. This information must
/// be stored by the application and guarantee that it will
/// not be modified. This is not enough information to recover
/// the keys, recovery words must also be specified and those
/// are not stored here. This is created by adding the parameters
/// of the scheme to the original words specified by the user.
/// At that point this structure is created which does not
/// contain the original words.
///
/// Some of the members here are best understood by reading the
/// whitepaper "Fuzzy Encryption for Secret Recovery", Ghosh et. al.
/// included in the Github repository
struct secret_t {
    int _setSize;           ///< the number of words to generate the secret/
                            ///< and recover the keys

    int _correctThreshold;  ///< this is the minimum number of of recovery
                            ///< words that match the original words
                            ///< in order to recover the keys

    int _corpusSize;        ///< this is the number of words in the set
                            ///< to be chosen from in this scheme.
                            ///< In this code a word is an integer in
                            ///< the range 0 .. coprusSize - 1

    int _prime;             ///< This is a prime number chosen by us
                            ///< in the range corpusSize < prime < 2*corpusSize
                            ///< The global modulus is set to this value
                            ///< using imod_t::initialize(). It serves as the
                            ///< modulus for all modular mathematics.

    std::vector<int> _extractor; ///< an array of bytes generated by the constructor
                                 ///< to be used at key recovery time.

    std::vector<uint8_t> _salt; ///< an array of bytes generated by the constructor
                                ///< to be used by the slow hash

    std::vector<int> _sketch;   ///< an array of integers used for key recovery

    std::vector<uint8_t> _hash; ///< a 512-bit hash of the original words.
                                ///< This is used as a check of the recovery
                                ///< and recovered words.

    /// Construct the secret using the specified parameters and words
    /// @param params The paramters of the scheme
    /// @param words The original words as specfied by the user
    secret_t(const params_t& params,
             const std::vector<int> words
             );
    
    /// Reconstruct a secret from its JSON representation
    /// @param json A JSON string containing the representation of a secret
    secret_t(std::string json);

    /// destroys all resources
    ~secret_t();

    /// Clears all of the vector members
    void clear();

    /// Calculates the 512-bit hash of a set of word and
    /// puts them in the destination
    /// @param words a list of words to be hashed
    /// @param hash the destination of the hash
    /// @returns void
    void get_hash(const std::vector<int>& words,
                  std::vector<uint8_t>& hash
                  ) const;
    
    /// An internal function used at key recovery time.
    /// @param words recovery words
    /// @param ek an array of bytes needed to generate all keys
    /// @returns void
    void get_ek(const std::vector<int>&words,
                std::vector<uint8_t>& ek
                ) const;

    /// An internal function used to get the hash of a set of words
    /// @param prefix a string to be converted to bytes that serves
    ///     as the leading bytes of the thing to be hashed
    /// @param words These are the words to be hashed. The are 
    ///     converted to bytes and appended to the bytes initalized
    ///     with the prefix
    /// @param scrypt This is the destination of the 512-bit hash
    /// @returns void
    void get_scrypt(const std::string& prefix,
                    const std::vector<int>& words,
                    std::vector<uint8_t>& scrypt
                    ) const;

    /// An internal function to attempt to recover the original words
    /// These words are never stored. They are generated to when
    /// recovering keys, checked against the hash of the original words
    /// if the hashes match then the keys can be recovered.
    ///
    /// If it is not possible to recover the words a NoSolutionException
    /// is thrown.
    /// @param recoveryWords A set of words that is a guess at the original words
    /// @param recoveredWords This is the destination of this function. If
    ///     the recovery words are within the correctThreshold then the
    ///     recovered words are set.
    /// @returns void

    void recover(const std::vector<int>& recoveryWords,
                 std::vector<int>& recoveredWords
                 ) const;

    /// An internal function to generate a key. The original words
    /// have been successfully recovered.
    /// @param ek data used in the recovery of all keys
    /// @param count the position of a key in a sequence of recovered keys
    /// @param key the destination where to put a 512-bit key
    void get_key(const std::vector<uint8_t>& ek,
                 int count,
                 std::vector<uint8_t>& key
                 ) const;
    
    /// Get a sequence of keys based upon the words
    /// @param words These are the words to be used to create the keys
    /// @param count the number of unique keys to be generated
    /// @param keys the list to into which the keys will be placed
    void get_keys(const std::vector<int> words,
                  int count,
                  std::vector<std::vector<uint8_t>>& keys
                  ) const;

    /// Returns the errorThreshold which is the maximum symmetric difference
    /// between the original and recovery words allowed.
    int errorThreshold() const { return 2 * (_setSize - _correctThreshold); }

    /// check that the set of words are legal. This means that they
    /// all satisfy 0 <= word < corpusSize and that none of the
    /// words are repeated
    /// @param words the set of words to be tested
    /// @param setSize the required number of words
    /// @param corpusSize the number used for checking bounds
    static void check_words(const std::vector<int>& words,
                            const int set_size,
                            const int corpus_size
                            );

    /// Generate data to be stored in the secret. They depend upon the
    /// original words. See the whitepaper.
    /// @param words the original words
    /// @param threshold symmetric error threshold
    /// @param destination
    static void gen_sketch(const std::vector<int>& words,
                           const int threshold,
                           std::vector<int>& sketch
                           );
    
    /// Internal function
    /// returns a polynomial used to recover the words
    /// @param ts the sketch
    /// @param s setSize
    static poly_t get_phigh(const std::vector<int>&ts,
                            const int s
                            );

    /// Internal function used to attempt to recover
    /// the original words from the recovery words
    /// @param words recovery words -- a guess at the original words
    /// @param sketch data generated at the time of the construction
    ///      of the secret.
    /// @param errorThreshold The maximum allowed symmetric difference
    ///     allowed between the original and recovery words
    /// @param out  destination for the recovered words
    static void recover_words(const std::vector<int>& words,
                              const std::vector<int>& sketch,
                              const int errorThreshold,
                              std::vector<int>& out
                              );
};

/// Writes a JSON representation of a secret to a stream
std::ostream& operator<<(std::ostream& os, const secret_t& secret);

#endif