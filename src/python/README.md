# Fuzzy Encryption for Secret Recovery
<br/>

**WARNING: This implementation is for prototype and testing purposes only. DO NOT use in production, as this implementation WILL NOT be supported. Another implementation of the Fuzzy Encryption scheme (written in C++) is under active development and will offer long-term production support after publication to this repository.**
**WARNING: This code relies on copyleft dependencies which may require special attention to use safely within commercial products. Please take care to ensure you are abiding by the license terms specified in these dependencies.**

Fuzzy Encryption for Secret Recovery project is an approach to provide an alternative for unmemorable user-controlled cryptographic keys composed of secret long strings of random numbers and letters. Our project presents a scheme where a user is expected to remember/securely protect a pass-phrase alone. This pass-phrase is used to generate cryptographic key material that is used to generate as well as recover cryptographic key(s). Configuration information generated by the scheme and used to generate the cryptographic key material from the pass-phrase can be stored in a public place. However, the configuration inputs cannot be modified, otherwise the generated secret can no longer be recovered.

## Table of Contents

- [Installation](#installation)
    - [Clone](#clone)
    - [Setup](#setup)
- [Documentation](#documentation)
  - [Understanding the code...](#understanding-the-code)
    - [InputParams (Class):](#inputparams-class)
    - [FuzzyState (Class):](#fuzzystate-class)
    - [GenerateSecret (Function):](#generatesecret-function)
    - [RecoverSecret (Function):](#recoversecret-function)
  - [Tests and Demos](#tests-and-demos)
- [Dependencies](#dependencies)

---

## Installation

*System Compatibility: Linux (Ubuntu or Debian distributions) or Windows using Windows Subsystem for Linux  (WSL2).*

You will need to clone this repo to your local machine. If you don't have git installed, you can simply do so by typing the following in command line (update the package index first):

```shell
$ sudo apt update 
$ sudo apt install git
```

#### Clone and Setup

Clone this repo to your local machine.
<br/>
Next, in order to install all needed dependencies before running or testing this program, you will need to run the bash script [install.sh](./install.sh).
If you're currently in the local directory where it resides, type the following in command line, otherwise replace with the correct PATH to [install.sh](./install.sh):

```bash
$ ./install.sh
```

If you receive the  <span style="color:red">error</span> below: 

**-bash: ./install.sh: Permission denied**

then you will need to change mode first, type the following in command line before retrying the previous step:

```bash
$ chmod +x ./install.sh
```
*Provide password for root access if asked, give permission for memory space usage and wait for the installations to complete, please note that this might take a while...*

---
## Documentation

### Understanding the code...
*We'll discuss some of the main classes and functions used in [fuzzy.py](./fuzzy.py) to generate and recover cryptographic keys using the user's pass-phrase.*

#### InputParams (Class):
This class initializes all input parameters used by `GenerateSecret()`, these parameters are:
1. `setsize`: this is the number of words required for establishing the initial secret and for recovering the secret. *This is specified by the user.*
2. `correctthreshold`: this is the minimum number of words that must be correctly guessed in order to successfully recover the secret. This must be greater than half of the number of words (`setsize`). *This is specified by the user.*
3. `corpus_size`: This is the size of the set of allowed words. This means that both the original words and recovery words must be represented by integers in the range 0 .. (`corpusSize` - 1). *This is specified by the user.*
4. `prime`: This a prime number (p) such that `setsize` < p < 2 * `setsize`. *The user does not set this number*, instead it is derived from the `corpusSize` which is specified by the user.
5. `salt`: bytes required for slowing down brute force attacks. Created by the constructor. This value is not specified by the user.
6. `extractor`: bytes required of key generation. Automatically generated by the constructor. *This value is not specified by the user.*

*Note that once these parameters are set, they will not be altered again for that code run, meaning they will be globally constant throughout the code.*

#### FuzzyState (Class):

The state is retained for recovering keys, this is what is sometimes referred to as the "payload". It's created at the time of the call to `GenerateSecret()`. It's up to the caller to save this information in the form of a JSON file. This is easy to do since the string representation of this object, as returned by `__repr__()`, is a string containing the JSON representation. This information is required by `RecoverSecret()`.

#### GenerateSecret (Function):
`GenerateSecret()` establishes the original words of the vault. In addition, it returns a state and a list of 512-bit keys. The state contains the information needed to recover the keys with `RecoverSecret()`.

*Return Output:*
1. `FuzzyState` object.
2. A list of `key_count` 512-bit keys.

*Input:*
1. `params`: This is an object of the class `InputParams` that contains the necessary input.
2. `original_words`: A list of unique of integers in the range 0 .. (`corpusSize` - 1) representing the secret words needed to recover the keys.
3. `key_count`: The initial number of keys requested.

#### RecoverSecret (Function):
`RecoverSecret()` recovers a `key_count` list of keys. 

*Return Output:*

1. A list of keys if successful. Otherwise, it throws a `FuzzyError exception` if the keys cannot be recovered.

*Input:*
1. `state`: The FuzzyState created by GenerateSecret.
2. `recovery_words`: A guess of the original words. These are unique integers in the range 0 .. `corpusSize` - 1.
3. `key_count`: The number of keys to be generated.

---
### Tests and Demos 
<br/>
After installing the necessary prerequisites and getting familiar with the code, we've provided a tutorial you can use to test and demo our scheme...

First, you will need to need to change your directory to the right PATH where the python files are located, as such:

```shell
$ cd PATH/
```
After that, you can start your demo by setting the parameters for generating your cryptographic key:

```shell
$ python3 gen_params.py
``` 
You can also add an option to set the path to another JSON file to hold the generated input parameters (default= `params.json`):

 ```shell
$ python3 gen_params.py --params-path TEXT
``` 
Specify your parameters (for the purpose of this tutorial, we will use the following example):
```
set size: 9
correct threshold: 7
corpus size: 7000
writing parameters to params.json
``` 
If you'd like to review the parameters you've set, you can simply open `params.json` (by default):
```shell
$ cat params.json
``` 
Output for our example:
```
{
  "setsize": 9,
  "corpusSize": 7000,
  "correctThreshold": 7,
  "prime": 7001,
  "extractor": [
    2771,
    3429,
    1060,
    4146,
    3277,
    4753,
    4128,
    3279,
    6433
  ],
  "salt": "8C0565D5 ... ABFABF615C35909CE1D9732"
}
``` 
Since we have our input parameters set, we can generate the cryptographic key, you can do so by typing the following in command line:
```shell
$ python3 gen_secret.py
```
Now you can choose your pass-phrase, make sure it has the same number of words as your `setsize` parameter, and that each word is unique and within the `corpus_size`. Note that we are using integers and not strings, but it's up to the developer to include a word-to-integer mapping function before utilizing our tool, for this example, we'll use the following pass-phrase:
```
words: 11 2 30 44 65 89 99 110 20

writing secret to secret.json
```
Now that we have our key, we might want to recover it, we can easily do so with the chosen pass-phrase or a *close enough* guess:
```shell
$ python3 gen_keys.py
```
For our example, the following inputs will all <span style="color:red">fail</span>:
```python
words: 11 2 30 44 65 89 99 110 #The number of words doesn't match the setSize, regardless of how many words are correct
words: 11 2 30 44 65 89 9 11 2 #Includes only 6 correct words and we need at least 7 correct words since the correctThreshold is 7.
```
If we input the correct pass-phrase or a guess within the correctThreshold, we can retrieve the key(s), here we use 8 correct words which is allowed:
```
words: 11 2 30 44 65 89 99 110 5 

keys:
- E8FF101BD69E2A252AA9E4 ... B175824B8881A29CEC
```

Each key is an upper case hex string representing a 512-bit (64 byte)
key. Each two hex characters represents a member of a 64-byte array
going from lowest position to highest.

#### Three stage example

To demonstrate the key recovery scheme we have provided three Python
scripts to demonstrate the process. These scripts are **gen_params.py** ,
**gen_secret.py** and **gen_keys.py** which are executed in that order.
To demonstrate their use call them with the **--help** argument. However,
the simplest demonstration of the key recovery scheme goes as follows:

```
  $ python3 gen_params.py
  set-size: 9
  correct-threshold: 6
  corpus-size: 7776
  writing parameters to params.json


  $ python3 gen_secret.py
  words: 1 2 3 4 5 6 7 8 9
  writing secret to secret.json


  $ python3 gen_keys.py
  words: 1 2 3 4 5 6 7 8 9
  keys:
  - 3EF257455A066C4D49186E........A57


  $ python3 gen_keys.py
  words: 11 12 13 4 5 6 7 8 9
  keys:
  - 3EF257455A066C4D49186E........A57


  $python3 gen_keys.py
  words: 11 12 13 14 5 6 7 8 9

  Key Recovery Failed:
      Remainder is not zero
```

First you call **gen_params.py** this establishes the 
security level of the system.
The parameters of the key recovery scheme are represented in JSON
format and stored, by default, in *params.json*.
In practice, this step is executed once by the architect of the 
recovery scheme and is used for all secret generation after that.

The second call is to **gen_secret.py** where the recovery words are
defined and encoded as a *secret*.
The name *secret* is misleading because **it is not a secret**.
Perhaps it should have been called a **vault** or **lock**.
Anyone can read it because it does not contain the recovery words
and it does not give any information as to what the recovery words are.
As we shall see below, the only way to generate keys is to unlock
the secret with the recovery words or a *close enough* match.
The secret is represented in JSON format and must be stored 
away, unmodified, for the key recovery stage.

In the last part of the demonstration we make three calls to 
**gen_keys.py** to attempt unlocking the **secret** and 
generating 512-bit keys. In the first attempt we supply the same
words as was used to generated the secret and the key recovery
was successful as you would expect. In the second attempt at 
key recovery we supply a flawed list of recovery words where only
size of the nine words are correct. The recovery is successful
because the number of correct words was withing the 
correct-threshold of six as defined in the call to **gen-secret.py** .
In the last attempt, we have forgotten too may of the 
original words and we correctly guess only five of the nine
original recovery words. This recovery fails as promised.

---
## Dependencies 
<br/>

Python packages needed to run `Fuzzy-KeyRecovery`'s code:

| Package      | Version   |   
|------------- | --------- |
| flint-py     | 0.3.5     |
| crypto       | 1.4.1     |
| pyOpenSSL    | 19.1.0    |
| click        | 7.1.2     |
| jsonschema   | 3.2.0     |
| sympy        | 1.6.2     |
| hashids      | 1.3.1     |
| scrypt       | 0.8.17    |
